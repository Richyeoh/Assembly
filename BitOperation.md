# X86 Assembly Language

## 位运算

上一篇讲完了计算机中数的概念，刚好也趁此机会讲一下计算机中的位运算。

补充：
在计算机二进制中高位的0表示正数，高位的1表示负数

## 原码、反码、补码

**原码** 就是将一个数字转换成二进制就是这个数值的原码

例如：

3和-7的原码如何表示?

``` Java
3   // 0000 0000 0000 0011 原码
-7  // 1000 0000 0000 0111 原码
```

**反码** 反码分两种情况：``正数和负数``

正数:`正数的反码就是原码`

负数:`负数的反码就是在原码的基础上符号位不变其他都取反`

例如:

3和-7的反码如何表示?

``` Java
3   // 0000 0000 0000 0011 原码亦是反码
-7  // 1000 0000 0000 0111 原码
-7  // 1111 1111 1111 1000 反码
```

**补码** 和反码一样补码也是区分：``正数和负数``

正数:`正数的原码也是补码`

负数:`负数的补码在反码的基础上加1`

例如:

3和-7的补码如何表示?

``` Java
3   // 0000 0000 0000 0011 原码亦是反码也是补码
-7  // 1000 0000 0000 0111 原码
-7  // 1111 1111 1111 1001 补码
```

再讲一个小知识吧：

**`在计算机中进行数值运算的时候是通过补码的方式表示每一个数值`**

例如:
``` Java
3 - 7 = 3 + (-7)
      = 0000 0000 0000 0011
      + 1111 1111 1111 1001
      = 1111 1111 1111 1100
      = -4
```

# 奔入主题

在开始讲位运算之前呢，我们先来讲一下计算中的Boolean类型吧，Boolean类型非假即真，取值为false和true，在计算机中内存的取值为0和1，即0表示false，1表示true。

在讲解位运算之前我还需要你们在脑海中做一个这样子映射，就是0是false，1是true。

## 开始正题

**&与运算** 定义:

**在两个数进行与运算时，从低位到高位一一比较，如果两个Bit位都为1时则相对应的结果为1，否则结果为0**

``` Java
1 & 1 = 1 0001 & 0001 = 0001
0 & 0 = 0 0000 & 0000 = 0000
1 & 0 = 0 0001 & 0000 = 0000
```

来吧，我们在加深一点印象，还记得我刚才让你们记得0是false，1是true了么？下面我们把它带入到我们开发常用的逻辑判断语句if中去。

``` Java
1 & 1 = 1 
0 & 0 = 0
    
0001 & 0001
//伪码：
int num1 = listOf(0,0,0,1)
int num2 = listOf(0,0,0,1)

int length = a.getLengths

bitRet = listOf() 

for(int index=0;index<length;index++){
    int a = num1[index]
    int b = num2[index]
    if(a==1&&b==1){
        bitRet.add(1)    
    }else{
        bitRet.add(0)
    }

    //或者
    if(a&b){
        bitRet.add(true)
    }else{
        bitRet.add(false)
    }
}
bitRet.flatRange = 0001

0表示false
1表示true
bitRet.flatBoolean = false,false,false,true = 0,0,0,1
```

**|或运算**定义:

**在两个数进行与运算时，从低位到高位一一比较，如果两个Bit位其中有一个为1那么结果为1，否则结果为0**

``` Java
0 | 0 = 0 0000 | 0000 = 0000
1 | 0 = 1 0001 | 0000 = 0001
1 | 1 = 1 0001 | 0001 = 0001
```

**~取反运算**定义:

**对每一位进行取反，0变为1，1变为0**

``` Java
~1 = -2 ~0001 = 1110 = -2 //符号高位1为负数
```

**^异或运算**

**在两个数进行异或运算时，从低位到高位一一比较，相同结果为0，不相同结果为1,0不参与运算**

```
0 ^ 0 = 0 0000 ^ 0000 = 0000
1 ^ 1 = 0 0001 ^ 0001 = 0000
1 ^ 0 = 1 0001 ^ 0000 = 0001
```

## 位移运算

位移运算相对较简单，我直接给出公式了。
```
4 >> 1 0100 >> 1 = 0010 = 2
6 >> 1 0110 >> 1 = 0011 = 3
```

右移运算 a >> b = a / (2^b)

```
4 << 1 0100 << 1 = 1000 = 8
6 << 1 0110 << 1 = 1100 = 12
```

左移运算 a << b = a * (2^b)
